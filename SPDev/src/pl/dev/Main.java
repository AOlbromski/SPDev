package pl.dev;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import pl.dev.factory.GraphFactory;
import pl.dev.model.graph.Graph;
import pl.dev.model.graph.Node;
import pl.dev.model.graph.Route;
import pl.dev.model.xml.Paths;


/**
 * This is the main class of the program.
 * It contains methods that solves the problem of Travelling Salesman problem. 
 * <p>
 *  
 *
 * @param  url  an absolute URL giving the base location of the image
 * @param  name the location of the image, relative to the url argument
 * @return      the image at the specified URL
 * @see         Image
 */
public class Main {
	
	/**
	 * This is a method that prepares weighted graph from imported XML data.
	 * <p>
	 *  
	 * @return      the weighted graph
	 * @see         Graph
	 */
	public static Graph buildGraph() {
		
		Paths paths = null;
		try {

			File file = new File("input.xml");
			JAXBContext jaxbContext = JAXBContext.newInstance(Paths.class);

			Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
			paths = (Paths) jaxbUnmarshaller.unmarshal(file);

		} catch (JAXBException e) {
			System.out.println("Invalid input data.");
		}

		return GraphFactory.buildGraph(paths);
	}
	
	/**
	 * This is the method that generates possilble solutions of given problem.
	 * It is called recursively until all nodes have been visited. 
	 * <p>
	 * 
	 * @param  node node that is currently visited
	 * @param  currentPath list of nodes that have beed visited until now
	 * @param  weight list of weights for current solution
	 * @param  paths complete solutions generated until now
	 * @param  maxNumber max number of nodes in graph
	 * @see         Node
	 */
	public static void buildHamiltonianCycles(Node node ,List<Node> currentPath ,List<Integer> weight, Map<String, Integer> paths, Integer maxNumber){
		for(Route route : node.getRoutes()){
			if(!currentPath.contains(route.getEndPoint())){
				
				currentPath.add(route.getEndPoint());
				weight.add(route.getWeight());
				buildHamiltonianCycles(
						route.getEndPoint(), 
						currentPath, 
						weight, 
						paths, 
						maxNumber);
				
				currentPath.remove(currentPath.size()-1);
				weight.remove(weight.size()-1);
				
			}else if(currentPath.size()==maxNumber && route.getEndPoint().equals(currentPath.get(0))){
				
				String s = "";
				Integer totalWeight=route.getWeight();
				
				for(Integer i : weight){
					totalWeight+=i;
				}
				
				for(Node n : currentPath){
					s=s+n.getName()+" ";
				}
				
				System.out.println(s+" length: "+totalWeight);
				paths.put(s,totalWeight);
			}
		}
	}
	
	
	/**
	 * This is the method that calls buildHamiltonianCycles and start solution generation.
	 * It collects all generated solutions and show best of them.
	 * <p>
	 * 
	 * @param  graph graph generated by buildGraph
	 */
	public static void getResult(Graph graph){
		
		List<Node> currentRoute = new ArrayList<Node>();
		currentRoute.add(graph.getFirst());
		Map<String,Integer> routes = new HashMap<String, Integer>();
		System.out.println("Possible solutions:");
		buildHamiltonianCycles(
				graph.getFirst(),
				currentRoute, 
				new ArrayList<Integer>(), 
				routes,graph.getNodes().size() 
								);
		
		Entry<String,Integer> minRoute = null;
		for(Entry<String, Integer> e : routes.entrySet()){
			if(minRoute==null || e.getValue()<minRoute.getValue()){
				minRoute=e;
			}
		}
		if(minRoute!=null){
			System.out.println("Best solution:");
			System.out.println(minRoute.getKey());
			System.out.println("With total length of: "+minRoute.getValue());
		}else{
			System.out.println("Solution have not been found.");
		}
	}

	public static void main(String[] args) {
		
		getResult(buildGraph());
	}
}
